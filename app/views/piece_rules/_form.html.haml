= semantic_form_for [@variant, @piece_rule] do |f|
  = f.inputs do
    - if f.object.persisted?
      = f.input :piece_type, input_html: { disabled: true }
    - else
      = f.input :piece_type, collection: PieceType.where.not(id: f.object.variant.piece_rules.pluck(:piece_type_id))

    = f.input :count, as: :number, min: 1, step: 1

  = f.inputs 'Movement' do
    = f.input :movement_type, collection: PieceRule::DIRECTIONS.map{|x| [x.humanize, x]}
    = f.input :movement_minimum, label: 'Minimum', as: :number, min: 1, step: 1
    = f.input :movement_maximum, label: 'Maximum', as: :number, min: 1, step: 1, placeholder: 'Leave blank for no maximum'

  = f.inputs 'Capture' do
    = f.input :capture_type, collection: PieceRule::CAPTURE_TYPES.map{|x| [x.humanize, x]}, input_html: {'data-dependent' => 'capture_type'}

    %div{'data-dependency' => 'capture_type', 'data-value' => 'range'}
      = f.input :range_type, collection: PieceRule::DIRECTIONS.map{|x| [x.humanize, x]}
      = f.input :range_minimum, label: 'Minimum', as: :number, min: 1, step: 1
      = f.input :range_maximum, label: 'Maximum', as: :number, min: 1, step: 1, placeholder: 'Leave blank for no maximum'
      = f.input :move_and_range_capture, label: 'Can move and capture in the same turn?'

  = f.actions do
    = f.action :submit
    = f.action :cancel, :url => @piece_rule.variant